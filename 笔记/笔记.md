# mysql 连接字符串

~~~json
"ConnectionStrings": {
    "guli": "Data Source =127.0.0.1;port=3306;Initial Catalog=guli;user id=root;password=123456;Character Set=utf8;sslmode=none"
  },
~~~



## 反向工程

> 使用该命令（PMC）生成DbContext和Model
>
> PM> Scaffold-DbContext "server=localhost;database=glkt_vod;username=root;password =123456;"  Pomelo.EntityFrameworkCore.MySql -Context VodDbContext -OutputDir ../ggkt.Model/Models/Vod -ContextDir ./



### 一.  反向工程

　　反向工程是基于数据库架构，生成的实体类和DbContext类代码的过程，对于Visual Studio开发，建议使用PMC。对于其他开发环境，请选择.NET Core CLI工具(跨平台)。

　　　　(1) 在程序包管理器控制台(PMC)工具中使用命令Scaffold-DbContext 来进行反向工程。

　　　　(2) 在.NET 命令行接口 (CLI) 工具中使用dotnet ef dbcontext scaffold命令来进行反向工程。

　　

 　**1.1 `Scaffold-DbContext``介绍`**

　　　　使用Scaffold-DbContext命令生成实体类型时，数据库表必须具有主键，没有主键的表不会被反向工程。下面是PMC下的参数表格介绍，对于CLI的scaffold参数介绍[参考官网](https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet#dotnet-ef-dbcontext-scaffold)

| **参数**             | **描述**                                                     |
| -------------------- | ------------------------------------------------------------ |
| -Connection <String> | 数据库的连接字符串。该参数，是必需的。                       |
| -Provider <String>   | 要使用的提供程序。通常，这是NuGet包的名称，例如：`Microsoft.EntityFrameworkCore.SqlServer`。该参数，是必需的。 |
| -OutputDir <String>  | 放入文件的目录。路径是相对于项目目录的。                     |
| -ContextDir <String> | 放置`DbContext`文件的目录。路径是相对于项目目录的。          |
| -Context <String>    | `DbContext`要生成的类的名称。                                |
| -Schemas <String []> | 用于生成实体类型的表的架构。如果省略此参数，则包括所有架构。例如在sqlserver上默认dbo架构 |
| -Tables <String []>  | 用于生成实体类型的表。如果省略此参数，则包括所有表。         |
| -DataAnnotations     | 使用属性配置模型（如果可能）。如果省略此参数，则仅使用fluent API。 |
| -UseDatabaseNames    | 使用与数据库中显示的完全相同的表和列名称。如果省略此参数，则更改数据库名称以更符合C＃名称样式约定。 |
| -Force               | 覆盖现有文件                                                 |

 

### 二. 命令参数详解

　　**2.1 必备参数**

　　　　-Connection <String>是第一个参数是数据库的连接字符串。 工具将使用此连接字符串来读取数据库架构。-Provider <String>是提供程序名称。

```
　　　　// PowerShell
　　　　Scaffold-DbContext 'Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Chinook'  Microsoft.EntityFrameworkCore.SqlServer

　　　　// dotnet
　　　　dotnet ef dbcontext scaffold "Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Chinook" Microsoft.EntityFrameworkCore.SqlServer
```

　　　　

 　**2.2 指定表和架构**

　　　　默认情况下，数据库架构中的所有表都被反向工程到实体类型，可以限制哪些表是反向工程，处理通过指定架构和表。

`　　　　　　-Schemas`在 PMC 中的参数和`—schema`CLI 中的选项可用于包含在架构中的每个表。  

　　　　　　`-Tables` (PMC) 和`--table`(CLI) 可用于包括特定的表。

　　　　若要在 PMC 中包含多个表，使用一个数组。若要在 CLI 中包含多个表，请多次指定选项。

```
　　　　// PowerShell
　　　　Scaffold-DbContext ... -Tables Blog, Post

　　　　// dotnet
　　　　dotnet ef dbcontext scaffold ... --table Blog --table Post
```

 　

　　**2.3 保留名称**

 　    默认情况下，数据库的表名称和列名称是固定的，以便更好地匹配实体名称和属性名称的.NET命名约定。在PMC中指定`-UseDatabaseNames`或在CLI中指定 `--use-database-names``，`使数据模型中的实体名称和属性名称与数据库中显示的的表和列名称完全相同。如果省略此参数，则可能会更改名称以更符合C＃命名约定。

 

　　**2.4** **Fluent API 或数据注释**

 　　　默认情况下，使用Fluent API配置实体类型。在PMC```中指定``-DataAnnotations`或在CLI中指定`--data-annotations`的情况下使用数据注释。下面二个代码块， 一个是使用Fluent API配置的，一个是使用数据注释，二者实现功能上一样。

```C#
        //Fluent API配置
        entity.Property(e => e.Title)
            .IsRequired()
        .HasMaxLength(160);

         //数据注释
        [Required]
        [StringLength(160)]
        public string Title { get; set; }
```

 

　　**2.5 DbContext 名称** 

 　　　默认情况下，DbContext 上下文名称是（数据库名+ Context后缀）*。* 若要自定义一个DbContext 上下文名称，在PMC中指定`-Context`或在CLI中指定`--context` 。

 

　　**2.6 目录和命名空间**

 　　　默认情况下，实体类和DbContext类被搭建到项目的根目录中，并使用项目的默认命名空间。在PMC中指定`-OutputDir`或在CLI中指定`--output-dir``将`指定目录。命名空间将是根命名称+子目录的名称。

​       下面使用`-ContextDir`(PMC) 和`--context-dir`(CLI) 来创建到一个单独的目录（Models），存放实体类和DbContext 类。

```
        // PowerShell
        Scaffold-DbContext ... -ContextDir Data -OutputDir Models
        // dotnet
         dotnet ef dbcontext scaffold ... --context-dir Data --output-dir Models
```

 

　　**2.7 更新模型**

　　　　当更改数据库后，可能需要更新EF Core模型以反映这些更改。如果数据库更改很简单，则最简单的方法是手动对EF Core模型进行更改。例如，重命名表或列，删除列或更新列的类型是在代码中进行的微不足道的更改。如果，数据库更改动作大。一个常见的工作流程是使用`-Force`（PMC）或`--force`（CLI）再次从数据库对模型进行反向工程，以使用更新的模型覆盖现有模型。

# Swagger

第一步：导包(我使用的是.net5.0的框架，所以导入5.x的包，如果你使用.net6.0的框架，注意改版本号)

~~~
Install-Package Swashbuckle.AspNetCore.Annotations -v 5.6.3
~~~


第二步：配置Swagger服务，调用EnableAnnotations()方法以启用注释

~~~C#
services.AddSwaggerGen(c =>
{
	c.EnableAnnotations();
});
~~~


第三步：之后在需要显示注释的Action上增加特性

~~~C#
[SwaggerOperation(Summary = "注释内容")]
~~~



这样你的Action看起来像这样

~~~c#
[Route("api/[controller]/[action]")]
[ApiController]
[SwaggerTag("讲师")]
public class TeacherController : ControllerBase
{}

[HttpGet]
[SwaggerOperation(Summary = "注释内容")]
public string Hello()
{
    return "hello";
}
~~~


启动项目即可在Swagger看到注释



# AutoMapper

安装Nuget AutoMapper.Extensions.Microsoft.DependencyInjection

定义一个类，继承Profile

~~~C#
public class CustomAutoMapperProfile : Profile
{
    public CustomAutoMapperProfile()
    {
        base.CreateMap<EduTeacher, EduTeacherDto>() // e表示EduTeacher；dto表示EduTeacherDto
                .ForMember(dto => dto.GmtCreate, // 将EduTeacher的DateTime类型映射为string类型
                opt => opt.MapFrom(
                    e => e.GmtCreate.ToString("yyyy-MM-dd HH:mm:ss")));
            
            base.CreateMap<EduTeacherDto, EduTeacher>()
                .ForMember(e => e.GmtCreate, // 将EduTeacherDto的string类映射为DateTime类型
                opt => opt.MapFrom(
                    dto =>DateTime.Parse(dto.GmtCreate)));
            //base.CreateMap<IEnumerable<EduTeacher>, IEnumerable<EduTeacherDto>>();
    }
}
~~~

在服务中注册

```C#
/// <summary>
/// 添加AutoMapper服务
/// </summary>
/// <param name="services"></param>
/// <returns></returns>
public static IServiceCollection AddCustomAutoMapper(IServiceCollection services) {
    services.AddAutoMapper(typeof(CustomAutoMapperProfile));
    return services;
}
```

构造函数注入

~~~C#
private readonly ITeacherService _teacherService;
private readonly IMapper _mapper;

public TeacherController(ITeacherService teacherService,IMapper mapper)
{
_teacherService = teacherService;
this._mapper = mapper;
}
~~~

使用

~~~C#
_mapper.Map<EduTeacherDto>(teacher)

_mapper.Map<IEnumerable<EduTeacherDto>>(pagelist.Data)
~~~



复杂映射

```C#
base.CreateMap<Admin, AdminDto>()
        .ForMember(dest => dest.RoleMsg, sourse => sourse.MapFrom(src => src.RoleInfo.RoleMsg));
```

```C#
User:
UserPwd	->不能返回到前端
UserName ->返回到前端
UserDTO:
UserName

```



# json处理

引用Newtonsoft.Json包

~~~C#
JsonConvert.SerializeObject(对象)  //可以将对象转换成json格式
~~~





# 统一返回结果

1、定义返回结果类

~~~C#
public class Result
    {
        public int Code { get; set; }
        public string Message { get; set; }
        public bool Success { get; set; }
        public dynamic Data { get; set; }
    }
~~~

2、统一返回结果

~~~C#
 public static class ApiResult
    {

        public static Result Ok() {
            return new Result {
                Code = 2000,
                Message="成功",
                Success=true,
                Data=null
            };
        }

        public static Result Ok(dynamic data) {
            return new Result {
                Code = 2000,
                Message = "成功",
                Success = true,
                Data=data
            };
        }

        public static Result Ok(string message)
        {
            return new Result
            {
                Code = 2000,
                Message = message,
                Success = true,
                Data = null
            };
        }

        public static Result Ok(string message,dynamic data)
        {
            return new Result
            {
                Code = 2000,
                Message = message,
                Success = true,
                Data = data
            };
        }

        public static Result Ok(int code,string message, dynamic data)
        {
            return new Result
            {
                Code = code,
                Message = message,
                Success = true,
                Data = data
            };
        }



        public static Result Error()
        {
            return new Result
            {
                Code = 2001,
                Message = "失败",
                Success = false,
                Data = null
            };
        }

        public static Result Error(string message)
        {
            return new Result
            {
                Code = 2001,
                Message = message,
                Success = false,
                Data = null
            };
        }

        public static Result Error(int code,string message)
        {
            return new Result
            {
                Code = code,
                Message = message,
                Success = false,
                Data = null
            };
        }
    }
~~~



3、返回结果

~~~C#
[HttpGet]
[SwaggerOperation(Summary = "查找所有讲师")]
public async Task<dynamic> FindAllTeacher(int index,int size)
{
    PageList pagelist = await _teacherService.Page(index,size);

    pagelist.Data = _mapper.Map<IEnumerable<EduTeacherDto>>(pagelist.Data);
	// 使用统一返回结果
    return ApiResult.Ok(pagelist);
}
~~~



# 统一异常处理

使用中间件拦截全局异常

1、创建异常处理中间件

~~~C#
public class CustomExceptionMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<CustomExceptionMiddleware> _logger;

        public CustomExceptionMiddleware(RequestDelegate next, ILogger<CustomExceptionMiddleware> logger)
        {
            this._next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context) {

            try
            {
                await _next.Invoke(context);
            }
            catch (Exception e)
            {
                // 输出日志
                _logger.LogError(e.Message);
                // 异常处理
                await HandleExceptionAsync(context,e);
            }

        }

        /// <summary>
        /// 设置异常统一放回结果
        /// </summary>
        /// <param name="context">HttpContext</param>
        /// <param name="e">异常</param>
        /// <returns></returns>
        public async Task HandleExceptionAsync(HttpContext context, Exception e) {
            Result result = new Result();
            // 获取异常状态码
            result.Code= e switch
                {
                    ApplicationException => (int)HttpStatusCode.BadRequest,
                    KeyNotFoundException => (int)HttpStatusCode.NotFound,
                    _ => (int)HttpStatusCode.InternalServerError
                };
            result.Message = e.Message;
            result.Data = null;
            result.Success = false;
            // 设置返回结果
            await context.Response.WriteAsync(JsonConvert.SerializeObject(result));
            
        }
    }
~~~



2、启用中间件

~~~C#
var app = builder.Build();

// 启用异常中间件
//  注意：进来将异常中间件放到最前面，以此来确保它能拦截到所有可能发生的异常
app.UseMiddleware<CustomExceptionMiddleware>();
~~~



# 统一日志处理

1、引入包

- Serilog.AspNetCore
- Serilog.Sinks.File

2、添加服务，输出到log文件

~~~C#
		/// <summary>
        /// 添加Serilog服务
        /// </summary>
        /// <param name="services"></param>
        /// <returns></returns>
        public static IServiceCollection AddSerilog(IServiceCollection services)
        {
            // 添加logging服务
            services.AddLogging(logBulider => {

                var outputTemplate = "{NewLine}【{Level:u3}】{Timestamp:yyyy-MM-dd HH:mm:ss.fff}" +
                                     "{NewLine}#Msg# {Message:lj}" +
                                     "{NewLine}#Pro# {Properties:j}" +
                                     "{NewLine}#Exc# {Exception}{NewLine}{NewLine}";//输出模板

                // 创建Logger,绑定Serilog
                var log = new LoggerConfiguration()
                .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
                .WriteTo.Console(restrictedToMinimumLevel: LogEventLevel.Information)
                .WriteTo.File(
                        Path.Combine("Log", "_log" + DateTime.Now.ToString("yyMM") + ".log"),   // 文件存放路径和名称
                        restrictedToMinimumLevel: LogEventLevel.Information,                    // 最低输出日志级别
                        outputTemplate: outputTemplate,                                         // 输出模板
                        rollingInterval: RollingInterval.Month,                                 // 日志按日保存，这样会在文件名称后自动加上日期后缀   
                        //fileSizeLimitBytes: 1024^2*20,                                         // 文件大小，单文件建议2M，这里30M；这里有问题，设置文件大小后，日志无法写入
                        encoding: Encoding.UTF8                                                 // 文件字符编码
                        )
                .CreateLogger();

                logBulider.AddSerilog(log); // 添加 Serilog 服务

            });
            return services;
        }

~~~

# 跨域处理

1、设置跨域

~~~C#
public static IServiceCollection AddCors(IServiceCollection services) {
    string[] urls = new[] { "http://localhost:9528", "http://127.0.0.1:5173" };

    services.AddCors(options =>
                     options.AddPolicy("cors", builder =>
                                       builder.WithOrigins(urls) // 设置允许访问的地址
                                       .AllowAnyMethod() // 允许任何方法
                                       .AllowAnyHeader() // 允许任何标头
                                       .AllowCredentials()));

    return services;
}
~~~



2、使用CORS策略

注意：UseCors()一定要放在UseHttpsRedirection()之前

~~~C#
app.UseCors("cors");

app.UseHttpsRedirection();
~~~

# 配置文件映射为配置类

1、appsettings.json配置文件

~~~json
	// 阿里云 OSS
  "AliyunOSSFile": {
    // 不同的服务器，地址不同
    "endpoint": "oss-cn-hangzhou.aliyuncs.com",
    "keyid": "LTAI5tP99kqXviatfYot2eAj",
    "keysecret": "aikw93YQh0DrxemO8lsX4BiqD3cP0n",
    //bucket可以在控制台创建，也可以使用C#代码创建
    "bucketname": "guli-edu-10001"
  }
~~~



2、映射

~~~C#
// 将配置文件映射为配置类，并加入到IOC容器中
var OssFile = builder.Configuration.GetSection("AliyunOSSFile");
builder.Services.AddSingleton(OssFile.Get<OssFileConfig>());
~~~



# 集成阿里云oss

用例：上传文件

1、安装包

~~~
Aliyun.OSS.SDK.NetCore
~~~

2、配置json文件

~~~json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  // 阿里云 OSS
  "AliyunOSSFile": {
    // 不同的服务器，地址不同
    "endpoint": "oss-cn-hangzhou.aliyuncs.com",
    "keyid": "LTAI5tP99kqXviatfYot2eAj",
    "keysecret": "aikw93YQh0DrxemO8lsX4BiqD3cP0n",
    //bucket可以在控制台创建，也可以使用C#代码创建
    "bucketname": "guli-edu-10001"
  }
}
~~~

3、编写配置类

~~~C#
/// <summary>
/// 阿里云OSS的配置类
/// </summary>
public class OssFileConfig
{
    /// <summary>
    /// Endpoint:填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。
    /// </summary>
    public string endpoint { get; set; } = null!;


    /// <summary>
    /// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。
    /// 强烈建议您创建并使用RAM用户进行API访问或日常运维，
    /// 请登录RAM控制台创建RAM用户。
    /// </summary>      
    public string keyid { get; set; } = null!;
    /// <summary>
    /// KeySecret
    /// </summary>
    public string keysecret { get; set; } = null!;

    /// <summary>
    /// BucketName:填写Bucket名称。
    /// </summary>
    public string bucketname { get; set; }
}
~~~



4、将服务添加到容器（ioc）

~~~C#
// 将配置文件映射为配置类，并加入到IOC容器中
var OssFile = builder.Configuration.GetSection("AliyunOSSFile");
builder.Services.AddSingleton(OssFile.Get<OssFileConfig>());

// 添加FileService服务
builder.Services.AddScoped<IFileService, FileService>();

// 添加公共服务
builder.Services.AddCommonService();
~~~



5、编写service

~~~c#
public class FileService : IFileService
{

    private readonly OssFileConfig _OssFileConfig;
    private readonly ILogger<FileService> _logger;

    public FileService(OssFileConfig ossFileConfig,ILogger<FileService> logger)
    {
        this._OssFileConfig = ossFileConfig;
        this._logger = logger;
    }

    /// <summary>
    /// 上传文件到阿里云OSS
    /// </summary>
    /// <param name="file"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public string Upload(IFormFile file)
    {
        if (file == null || file.Length <= 0)
        {
            throw new Exception("没有上传文件");
        }
        // 文件上传的路径
        string filePath = Path.Combine("TeacherHeadPortrait/" , Guid.NewGuid().ToString().Replace("-","") + "_" + file.FileName);

        // 拼接文件的url，后续返回给前端
        string filrUrl = "http://" + _OssFileConfig.bucketname + "." + _OssFileConfig.endpoint + "/" + filePath;

        // 创建OSSClient实例。
        var client = new OssClient(_OssFileConfig.endpoint, _OssFileConfig.keyid, _OssFileConfig.keysecret);
        try
        {
            // 将文件转换为流
            using Stream stream = file.OpenReadStream();
            // 上传文件。
            var result = client.PutObject(_OssFileConfig.bucketname, filePath, stream);
            //_logger.LogInformation("文件上传成功, ETag: {0} ", result.ETag);
        }
        catch (Exception e)
        {
            _logger.LogError("文件上传失败, {0}", e.Message);
            throw new Exception("文件上传失败,"+ e.Message);
        }
        return filrUrl;
    }
}
~~~



# 使用MiniExcel导入导出Excel表格

地址：https://toscode.gitee.com/dotnetchina/MiniExcel/

安装包

~~~
Install-Package MiniExcel -Version 1.26.7
~~~



demo示例：

创建DemoData：

~~~C#
public class DemoData
{
    public int Id { get; set; }
    public string Name { get; set; }
}
~~~

写/导出

~~~C#
// 设置导出路径
var path = Path.Combine("F:\\", $"{Guid.NewGuid()}.xlsx");
MiniExcel.SaveAsAsync(path, new DemoData[] {
	new DemoData{ Id=1,Name="张三" },
	new DemoData{Id = 2, Name = "李四"}
});
~~~

读/导入

~~~C#
string path = "F:\\a8bffabc-c38d-4917-bcdc-32d27d8f2e69.xlsx";

var rows = MiniExcel.Query<DemoData>(path).ToList();

// or 
using (var stream = File.OpenRead(path))
{
    var rows = stream.Query<DemoData>().ToList();

	foreach (var item in rows)
	{
		Console.WriteLine(item.Name);
	}
}
~~~



.net6中使用

~~~C#
/// <summary>
/// 批量导入
/// </summary>
/// <param name="file"></param>
public async Task BatchImport(IFormFile file)
{
    // 读取Excel文件的内容
    using var stream = new MemoryStream();
    file.CopyTo(stream);
    var rows = stream.Query<SubjectData>().ToList();

    // 存放已经存在的一级分类
    IDictionary<string,string> oneSudjectDictionary = new Dictionary<string,string>();

    for (int i = 0; i < rows.Count; i++)
    {
        // 每次查询一级分类的Id之前，先oneSudjectDictionary中是否存在一级分类的Id；
        // 若存在就不用再去查询数据库了
        if (!oneSudjectDictionary.ContainsKey(rows[i].OneSudjectName))
        {
            string oneSudjectId = "";
            EduSubject oneSubject = await GetOneSudject(rows[i].OneSudjectName);
            if (oneSubject==null)// 判断是否存在该一级分类
            {
                // 若不存在，添加该分类
                oneSudjectId = AddOneSudject(rows[i].OneSudjectName);
            }
            else
            {
                // 若存在，则查询该分类
                oneSubject = await _subjectRepository.GetEntityAsync(s => s.Title == rows[i].OneSudjectName);
                oneSudjectId = oneSubject.Id;
            }
            oneSudjectDictionary.Add(rows[i].OneSudjectName, oneSudjectId);
        }

        // 拿到最大的Sort，在它的基础上加一，就是新Sudject对象的sort属性
        uint sort = _subjectRepository.GetAllAsync().Where(s=>s.ParentId!="0").Max(s => s.Sort) + 1;

        EduSubject subject = new EduSubject() {
            Id = Guid.NewGuid().ToString().Replace("-", ""),
            ParentId = oneSudjectDictionary[rows[i].OneSudjectName],
            Sort = sort,
            Title = rows[i].TwoSudjectName,
            GmtCreate=DateTime.Now,
            GmtModified=DateTime.Now
        };

        _subjectRepository.Add(subject);

    }

    // 统一保存
    await _subjectRepository.SaveAsync();

}

/// <summary>
/// 添加一级分类
/// </summary>
/// <param name="oneSudjectName">一级分类的名称</param>
/// <returns></returns>
private string AddOneSudject(string oneSudjectName)
{
    // 拿到最大的Sort，在它的基础上加一，就是新Sudject对象的sort属性
    uint sort = _subjectRepository.GetAllAsync().Where(s=>s.ParentId=="0").Max(s => s.Sort) + 1;

    EduSubject subject = new EduSubject() {
        Id = Guid.NewGuid().ToString().Replace("-", ""),
        ParentId = "0",
        Sort = sort,
        Title = oneSudjectName,
        GmtCreate = DateTime.Now,
        GmtModified=DateTime.Now
    };

    _subjectRepository.Add(subject);

    return subject.Id;

}

/// <summary>
/// 获取一级类别
/// </summary>
/// <param name="oneSudject"></param>
/// <returns></returns>
private async Task<EduSubject> GetOneSudject(string oneSudject)
{
    EduSubject subject = await _subjectRepository.GetEntityAsync(s => s.Title == oneSudject);

    return subject;
}
~~~



# 集成阿里云视频点播

官网示例：[基于OSS原生SDK上传 (aliyun.com)](https://help.aliyun.com/document_detail/61388.htm?spm=a2c4g.11186623.0.0.768d15e5TTuIS3#section-acz-afe-goi)

上传流程

**步骤一、安装点播服务端SDK**

[服务端SDK（.NET SDK）](https://help.aliyun.com/document_detail/57726.html)

**步骤二、安装OSS SDK并初始化**

[安装 (aliyun.com)](https://help.aliyun.com/document_detail/32086.htm?spm=a2c4g.11186623.0.0.7c436bc1aqs0Y2#concept-32086-zh)

**步骤三、初始化点播客户端**

~~~C#
public static DefaultAcsClient InitVodClient(string accessKeyId, string accessKeySecret)
{
    // 根据点播接入服务所在的Region填写，例如：接入服务在上海，则填cn-shanghai
    string regionId = "cn-shanghai";
    IClientProfile profile = DefaultProfile.GetProfile(regionId, accessKeyId, accessKeySecret);
    return new DefaultAcsClient(profile);
}
~~~

**步骤四、完成上传**

1. 获取上传地址和凭证（以上传视频为例）。

   ~~~C#
   public static CreateUploadVideoResponse CreateUploadVideo(DefaultAcsClient vodClient)
   {
       CreateUploadVideoRequest request = new CreateUploadVideoRequest();
       request.AcceptFormat = Aliyun.Acs.Core.Http.FormatType.JSON;
       request.FileName = "vod_test.mp4";
       request.Title = "this is title";
       //request.Description = "<文件描述>";
       //request.Tags = "<标签，多个标签用逗号分开>";
       //CoverURL示例：http://example.aliyundoc.com/test_cover_****.jpg
       //request.CoverURL = "<视频封面>";
       //媒体分类。登录点播控制台
       //request.CateId = -1;
       //转码模板组ID。登录点播控制台
       //request.TemplateGroupId = "<转码模板组ID>";
       //工作流ID。可登录点播控制台
       //request.WorkflowId = "<工作流ID>";
       //存储地址。登录点播控制台
       //request.StorageLocation = "<存储地址>";
       //AppId为固定取值。
       //request.AppId = "app-1000000";
       //设置请求超时时间
       request.SetReadTimeoutInMilliSeconds(1000);
       request.SetConnectTimeoutInMilliSeconds(1000);
       return vodClient.GetAcsResponse(request);
   }
   ~~~

   

2. Base64解析获取到的UploadAddress和UploadAuth。

   ~~~C#
   /// <summary>
   /// base64加密
   /// </summary>
   /// <param name="text">要加密的字符串</param>
   /// <returns></returns>
   public static string Base64_Encode(string text) {
       return (Convert.ToBase64String(Encoding.Default.GetBytes(text)));
   }
   
   /// <summary>
   /// base64解密
   /// </summary>
   /// <param name="text">要解密的字符串</param>
   /// <returns></returns>
   public static string Base64_Decode(string text) 
   {
       return (Encoding.Default.GetString(Convert.FromBase64String(text)));
   }
   ~~~

   

3. 使用上传凭证和地址初始化OSS客户端。

   > **注意**
   >
   > - 需要先Base64解码并JSON Decode再传入。
   > - 必须使用STS方式初始化OSS客户端。

   ~~~C#
   public static OssClient InitOssClient(JObject uploadAuth, JObject uploadAddress) 
   {
       string endpoint = uploadAddress.GetValue("Endpoint").ToString();
       string accessKeyId = uploadAuth.GetValue("AccessKeyId").ToString();
       string accessKeySecret = uploadAuth.GetValue("AccessKeySecret").ToString();
       string securityToken = uploadAuth.GetValue("SecurityToken").ToString();
       return new OssClient(endpoint, accessKeyId, accessKeySecret, securityToken);
   }
   ~~~

   

4. 上传本地文件。

   ~~~C#
   public static void UploadLocalFile(OssClient ossClient, JObject uploadAddress, string localFile) 
   {
       string bucketName = uploadAddress.GetValue("Bucket").ToString();
       string objectName = uploadAddress.GetValue("FileName").ToString();
       ossClient.PutObject(bucketName, objectName, localFile);
   }
   ~~~

   

5. （可选）如果上传凭证过期，可刷新上传凭证再上传。

   ~~~C#
   public static RefreshUploadVideoResponse RefreshUploadVideo(DefaultAcsClient vodClient)
   {
       RefreshUploadVideoRequest request = new RefreshUploadVideoRequest();
       request.AcceptFormat = Aliyun.Acs.Core.Http.FormatType.JSON;
       request.VideoId = "VideoId";
       //设置请求超时时间
       request.SetReadTimeoutInMilliSeconds(1000);
       request.SetConnectTimeoutInMilliSeconds(1000);
       return vodClient.GetAcsResponse(request);
   }
   ~~~

   

6. 执行完整流程（注意捕获异常）。

   ~~~C#
   //您的AccessKeyId
   string accessKeyId = "<Your AccessKeyId>"; 
   //您的AccessKeySecret
   string accessKeySecret = "<Your AccessKeySecret>";
   //需要上传到VOD的本地视频文件的完整路径，需要包含文件扩展名
   string localFile = "/Users/yours/Video/testVideo.flv";
   try {
       // 初始化VOD客户端并获取上传地址和凭证
       DefaultAcsClient vodClient = InitVodClient(accessKeyId, accessKeySecret);
       CreateUploadVideoResponse createUploadVideoResponse = CreateUploadVideo(vodClient);
       // 执行成功会返回VideoId、UploadAddress和UploadAuth
       String videoId = createUploadVideoResponse.VideoId;
       JObject uploadAuth = JObject.Parse(Base64Decode(createUploadVideoResponse.UploadAuth));
       JObject uploadAddress = JObject.Parse(Base64Decode(createUploadVideoResponse.UploadAddress));
       // 使用UploadAuth和UploadAddress初始化OSS客户端
       OssClient ossClient = InitOssClient(uploadAuth, uploadAddress);
       // 上传文件，注意是同步上传会阻塞等待，耗时与文件大小和网络上行带宽有关
       UploadLocalFile(ossClient, uploadAddress, localFile);
       Console.WriteLine("Put local file succeed, VideoId : " + videoId);
   } 
   catch (Exception e) 
   {
       Console.WriteLine("Put local file fail, ErrorMessage : " + e.Message);
   }
   ~~~

   

   完整示例：

   appsettings.json

   ~~~json
   // 使用阿里云视频点播使用的AccessKey
     "UploadVideo": {
       "AccessKeyId": "你的AccessKeyId",
       "AccessKeySecret": "你的AccessKeySecret"
     },
   ~~~

   base64解析

   ~~~C#
   /// <summary>
           /// base64解密
           /// </summary>
           /// <param name="text">要解密的字符串</param>
           /// <returns></returns>
           public static string Base64_Decode(string text) 
           {
               return (Encoding.Default.GetString(Convert.FromBase64String(text)));
           }
   ~~~

   

   上传视频帮助类：UploadVideoHelper.cs

   ~~~C#
    /// <summary>
       /// 上传视频
       /// </summary>
       public class UploadVideoHelper
       {
   
           private readonly UploadVideoConfig _videoConfig;
   
           public UploadVideoHelper(UploadVideoConfig videoConfig)
           {
               _videoConfig = videoConfig;
           }
   
           /// <summary>
           /// 初始化点播客户端
           /// </summary>
           /// <param name="accessKeyId">访问密钥标识</param>
           /// <param name="accessKeySecret">访问密钥</param>
           /// <returns></returns>
           public DefaultAcsClient InitVodClient()
           {
               // 点播服务接入区域
               string regionId = "cn-shanghai";
               //填写AccessKey信息
               IClientProfile profile = DefaultProfile.GetProfile(regionId, _videoConfig.AccessKeyId, _videoConfig.AccessKeySecret);
               return new DefaultAcsClient(profile);
           }
   
           /// <summary>
           /// 获取上传地址和凭证
           /// </summary>
           /// <param name="vodClient"></param>
           /// <returns></returns>
           public CreateUploadVideoResponse CreateUploadVideo(DefaultAcsClient vodClient,string title,string fileName)
           {
               CreateUploadVideoRequest request = new CreateUploadVideoRequest();
               request.AcceptFormat = Aliyun.Acs.Core.Http.FormatType.JSON;
               request.FileName = fileName;
               request.Title = title;
               //request.Description = "<文件描述>";
               //request.Tags = "<标签，多个标签用逗号分开>";
               //CoverURL示例：http://example.aliyundoc.com/test_cover_****.jpg
               //request.CoverURL = "<视频封面>";
               //媒体分类。登录点播控制台
               request.CateId = 1000442144;
               //转码模板组ID。登录点播控制台
               request.TemplateGroupId = "VOD_NO_TRANSCODE";
               //工作流ID。可登录点播控制台
               //request.WorkflowId = "<工作流ID>";
               //存储地址。登录点播控制台
               //request.StorageLocation = "<存储地址>";
               //AppId为固定取值。
               //request.AppId = "app-1000000";
               //设置请求超时时间
               request.SetReadTimeoutInMilliSeconds(1000);
               request.SetConnectTimeoutInMilliSeconds(1000);
               return vodClient.GetAcsResponse(request);
           }
   
           /// <summary>
           /// 初始化OSS客户端
           /// </summary>
           /// <param name="uploadAuth">上传凭证</param>
           /// <param name="uploadAddress">上传地址</param>
           /// <returns></returns>
           public OssClient InitOssClient(JObject uploadAuth, JObject uploadAddress)
           {
               string endpoint = uploadAddress.GetValue("Endpoint").ToString();
               string accessKeyId = uploadAuth.GetValue("AccessKeyId").ToString();
               string accessKeySecret = uploadAuth.GetValue("AccessKeySecret").ToString();
               string securityToken = uploadAuth.GetValue("SecurityToken").ToString();
               return new OssClient(endpoint, accessKeyId, accessKeySecret, securityToken);
           }
   
   
           /// <summary>
           /// 刷新上传凭证;
           /// 如果上传凭证过期，可刷新上传凭证再上传
           /// </summary>
           /// <param name="vodClient">初始化后的客户端</param>
           /// <param name="videoId">之前获取的Vodeoid</param>
           /// <returns></returns>
           public RefreshUploadVideoResponse RefreshUploadVideo(DefaultAcsClient vodClient,string videoId)
           {
               RefreshUploadVideoRequest request = new RefreshUploadVideoRequest();
               request.AcceptFormat = Aliyun.Acs.Core.Http.FormatType.JSON;
               request.VideoId = videoId;
               //设置请求超时时间
               request.SetReadTimeoutInMilliSeconds(1000);
               request.SetConnectTimeoutInMilliSeconds(1000);
               return vodClient.GetAcsResponse(request);
           }
   
           /// <summary>
           /// 上传文件
           /// </summary>
           /// <param name="ossClient">oss客户端</param>
           /// <param name="uploadAddress">上传地址</param>
           /// <param name="file">上传文件</param>
           public void UploadLocalFile(OssClient ossClient, JObject uploadAddress, IFormFile file)
           {
               try
               {
                   string bucketName = uploadAddress.GetValue("Bucket").ToString();
                   string objectName = uploadAddress.GetValue("FileName").ToString();
                   using Stream stream = file.OpenReadStream();
                   ossClient.PutObject(bucketName, objectName, stream);
               }
               catch (Exception e)
               {
                   throw e;
               }
           }
       }
   ~~~

   

   IVideorService中创建方法：

   ~~~C#
   /// <summary>
   /// 上传小节视频
   /// </summary>
   /// <param name="file">视频文件</param>
   /// <returns></returns>
   public Task<string> UploadVideo(IFormFile file, string title, string fileName);
   ~~~

   VideorService实现

   ~~~C#
    public async Task<string> UploadVideo(IFormFile file, string title, string fileName)
    {
        string videoId = "";
        try
        {
            // 初始化VOD客户端并获取上传地址和凭证
            DefaultAcsClient vodClient = _uploadVideoHelper.InitVodClient();
            CreateUploadVideoResponse createUploadVideoResponse = _uploadVideoHelper.CreateUploadVideo(vodClient,title,fileName);
   
            // 执行成功会返回VideoId、UploadAddress和UploadAuth
            videoId = createUploadVideoResponse.VideoId;
            JObject uploadAuth = JObject.Parse(Base64Helper.Base64_Decode(createUploadVideoResponse.UploadAuth));
            JObject uploadAddress = JObject.Parse(Base64Helper.Base64_Decode(createUploadVideoResponse.UploadAddress));
   
            // 使用UploadAuth和UploadAddress初始化OSS客户端
            OssClient ossClient = _uploadVideoHelper.InitOssClient(uploadAuth, uploadAddress);
            await Task.Run(() =>
                           {
                               // 上传文件，注意是同步上传会阻塞等待，耗时与文件大小和网络上行带宽有关
                               _uploadVideoHelper.UploadLocalFile(ossClient, uploadAddress, file);
                           });
   
        }
        catch (Exception e)
        {
            throw e;
        }
   
        return videoId;
    }
   ~~~

   控制器中的实现：VideoController

   ~~~C#
   [HttpPost("upload")]
   [SwaggerOperation(Summary ="上传视频")]
   public async Task<Result> UploadVideo(IFormFile file) {
       string videoId = await _videorService.UploadVideo(file,file.Name,file.FileName);
       return ApiResult.Ok(data: videoId, message: "上传成功");
   }
   ~~~

   









# 做项目遇到的坑

## 搜索（条件筛选）

后端：

在做搜索时，使用linq做条件筛选，直接拼接`Expression<Func<EduTeacher,bool>>`类型的条件表达式，发现无法拼接；后来想先使用`Func<EduTeacher,bool>`类型的委托，进行拼接条件，之后再将`Func<EduTeacher,bool>`类型转换为`Expression<Func<EduTeacher,bool>>`类型，结果发现无法转换。后来使用`IQueryable<T>`才解决拼接条件的问题；我将Repository的`GetAll()`方法重写，让它返回`IQueryable<T>`类型（之前是返回`IEnumerable<T>`类型），在`IQueryable<T>`的基础之上，再进行`where()`条件拼接，最后`ToListAsync()`执行查询

~~~C#
/// <summary>
/// 分页
/// </summary>
/// <param name="index">页码</param>
/// <param name="size">每页显示多少条数据</param>
/// <param name="searchObj">筛选条件</param>
/// <returns></returns>
/// <exception cref="Exception"></exception>
public async Task<PageList> Page(int index, int size, EduTeacherSearchRequest? searchObj)
{
    if (searchObj==null)
    {
        throw new Exception("筛选条件对象（searchObj）不能为null");
    }

    IQueryable<EduTeacher> data = _repository.GetAllAsync();


    if (!string.IsNullOrEmpty(searchObj.name))
    {
        data =data.Where(t => t.Name == searchObj.name);
    }

    
    if (searchObj.level != null && searchObj.level != 0)      
    {
        data = data.Where(t => t.Level == searchObj.level);
    }

    if (!string.IsNullOrEmpty(searchObj.begin) )
    {
        data = data.Where(t => t.GmtCreate >= DateTime.Parse(searchObj.begin));
    }

    if (!string.IsNullOrEmpty(searchObj.end ))
    {
        data = data.Where(t => t.GmtCreate <= DateTime.Parse(searchObj.end));
    }
    
	// 执行查询操作
    List<EduTeacher> list = await data.OrderBy(t => t.GmtCreate).Skip((index-1)*size).Take(size).ToListAsync();

    // 封装数据
    return new PageList(list,index,size,list.Count);
}
~~~



前端：

点击搜索按钮时，发现请求一直报`415`的错误，但是postman和swagger测试中，并没有发现问题；之后发现使用`axios`的`post`提交时，`Content-Type`是`application/x-www-form-urlencoded`类型，所有报`415`错误；最后将`application/x-www-form-urlencoded`类型改为`application/json; charset=utf-8`，就可以正常访问后端接口

~~~js
return request({
    url: `${api_name}/${page}/${limit}`,
    method: "post",
    data: JSON.stringify(searchObj),// 将数据转为json格式
    // 注意，这里使用axios的post提交时，Content-Type是application/x-www-form-urlencoded
    //      所有一直报415的错误，因此在post提交时，要将Content-Type改为application/json; charset=utf-8
    headers:{"Content-Type":"application/json; charset=utf-8"} 
    });
~~~



## 使用ef的联合查询

主要使用`Join(),GroupJoin(),SelectMany(),DefaultIfEmpty()`

`Join()：`是内连接（`INNER JOIN`），会将为null的数据过滤掉

`GroupJoin()：`是用来做多表联合查询的，主要是一对多的关系表时，会用到

`SelectMany()：`用来合并列表

`DefaultIfEmpty()：`它的作用是当连接的表为空时也会有一条空的数据，达到了left join的效果。

同时使用`GroupJoin(),SelectMany(),DefaultIfEmpty()`方法，实现外连接查询（`LEFT JOIN/RIGHT JOIN`）

使用EF的`Join()`方法进行联合查询，会将自动为null的数据自动过滤掉

~~~C#
		/// <summary>
        /// course、teacher、subject三张表关联，
        /// 返回前端course列表所需要的数据
        /// </summary>
        /// <returns></returns>
        public async Task<PageList> CourseJoinSubjectJoinTeacher(int index,int size,EduCourseSearchRequest? search) {
            var course = _dbContext.EduCourses.Where(c=>true);

            if (!string.IsNullOrEmpty(search.SubjectParentId))
            {
                course = course.Where(s => s.SubjectParentId == search.SubjectParentId);
                if (!string.IsNullOrEmpty(search.SubjectId))
                {
                    course = course.Where(s => s.SubjectId == search.SubjectId);
                }
            }

            if (!string.IsNullOrEmpty(search.Title))
            {
                course = course.Where(s => s.Title == search.Title);
            }

            if (!string.IsNullOrEmpty(search.TeacherId))
            {
                course = course.Where(s => s.TeacherId == search.TeacherId);
            }

            // 分页，找到课程信息
            course = course.OrderBy(s => s.GmtCreate).Skip((index - 1) * size).Take(size);


            // 先和teacher表关联，找到老师名称
            var data = course.Join(_dbContext.EduTeachers, c => c.TeacherId, t => t.Id, (c, t) => new
            {
                course = c,
                TeacherName = t.Name
            })
                // 再和subject表关联，找到二级分类
                .Join(_dbContext.EduSubjects, c => c.course.SubjectId, s => s.Id, (c, s) => new
                {
                    course = c.course,
                    TeacherName = c.TeacherName,
                    subjectTitle = s.Title,
                    SubjectId = s.Id
                })
                // 最后再和subject表关联，找一级分类；        
                .Join(_dbContext.EduSubjects, c => c.course.SubjectParentId, s => s.Id, (c, s) => new
                {
                    // 拿到所有需要的数据后，整理需要的数据
                    id = c.course.Id,
                    cover = c.course.Cover,
                    title = c.course.Title,
                    subjectParentTitle = s.Title,
                    subjectTitle = c.subjectTitle,
                    lessonNum = c.course.LessonNum,
                    viewCount = c.course.ViewCount,
                    buyCount = c.course.BuyCount,
                    teacherName = c.TeacherName,
                    price = c.course.Price,
                    status = c.course.Status,
                    createTime = c.course.GmtCreate
                });
            var list = await data.ToListAsync();
            
            
            //左连接的实现
            
            //var data = course.GroupJoin(_dbContext.EduTeachers, c => c.TeacherId, t => t.Id, (c, t) => new {
            //    course = c,
            //    teacher = t
            //}).SelectMany(combination=> combination.teacher.DefaultIfEmpty(), (course, teacher) => new {
            //    course = course.course,
            //    TeacherName=teacher.Name
            //})
            //    // 再和subject表关联，找到二级分类
            //    .GroupJoin(_dbContext.EduSubjects, c => c.course.SubjectId, s => s.Id, (c, s) => new {
            //        course = c.course,
            //        TeacherName = c.TeacherName,
            //        subject=s
            //    }).SelectMany(combination=> combination.subject.DefaultIfEmpty(),(course, subject)=>new {
            //        course = course.course,
            //        TeacherName = course.TeacherName,
            //        subjectTitle=subject.Title,
            //        SubjectId=subject.Id
            //    })
            //    // 最后再和subject表关联，找一级分类；        
            //    .GroupJoin(_dbContext.EduSubjects, c => c.course.SubjectParentId, s => s.Id, (course, subject) => new {
            //        // 拿到所有需要的数据后，整理需要的数据
            //        course = course.course,
            //        TeacherName = course.TeacherName,
            //        subjectTitle = course.subjectTitle,
            //        SubjectId = course.SubjectId,
            //        subjectParent=subject,             
            //    }).SelectMany(c=>c.subjectParent.DefaultIfEmpty(),(crouse, subjectParent) => new {
            //        id = crouse.course.Id,
            //        cover = crouse.course.Cover,
            //        title = crouse.course.Title,
            //        subjectTitle = crouse.subjectTitle,
            //        lessonNum = crouse.course.LessonNum,
            //        viewCount = crouse.course.ViewCount,
            //        buyCount = crouse.course.BuyCount,
            //        teacherName = crouse.TeacherName,
            //        price = crouse.course.Price,
            //        status = crouse.course.Status,
            //        createTime = crouse.course.GmtCreate,
            //        subjectParentTitle = subjectParent.Title,
            //        subjectParentId= subjectParent.Id
            //    });
            //var list = await data.ToListAsync();

            return new PageList(data, index, size, list.Count);
        }
~~~





### **左连接查询案例：**

Person表在EF Core中的实体类，如下：

```C#
public partial class Person
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int? Age { get; set; }
    public DateTime? CreateTime { get; set; }
    public string Flag { get; set; }
    public string VarCharDescription { get; set; }
}
```

Products表在EF Core中的实体类，如下：

~~~C#
public partial class Products
{
    public int Id { get; set; }
    public string Product { get; set; }
}
~~~

然后Person表和Products表，在SQL Server数据库中的数据如下所示：

![img](https://img2018.cnblogs.com/common/66059/202002/66059-20200217230025428-1311492058.png)

 

最后我们要结合**GroupJoin**、**SelectMany**和**DefaultIfEmpty**三个Linq函数，来在EF Core上实现Person **LEFT JOIN** Products的SQL语句，如下所示：

~~~C#
class Program
{
    static void Main(string[] args)
    {
        using (TestDBContext dbContext = new TestDBContext())
        {
            //Person LEFT JOIN Products
            var joinResults = dbContext
                            .Person
                            .GroupJoin(dbContext.Products, person => person.Id, product => product.Id, (person, products) => new { Person = person, Products = products })
                            .SelectMany(combination => combination.Products.DefaultIfEmpty(), (person, products) => new { PersonId = person.Person.Id, PersonName = person.Person.Name, ProductsId = products.Id, ProductsName = products.Product }).ToList();

            foreach (var joinResult in joinResults)
            {
                Console.WriteLine("PersonId={0}, PersonName={1}, ProductsId={2}, ProductsName={3}", joinResult.PersonId.ToString(), joinResult.PersonName == null ? "Null" : joinResult.PersonName, joinResult.ProductsId.ToString(), joinResult.ProductsName == null ? "Null" : joinResult.ProductsName);
            }
        }

        Console.WriteLine("Press any key to end...");
        Console.ReadKey();
    }
}
~~~

我们可以通过EF Core的后台日志，看到EF Core生成的SQL语句如下所示：

~~~sql
SELECT [p].[ID] AS [PersonId], [p].[Name] AS [PersonName], [p0].[id] AS [ProductsId], [p0].[product] AS [ProductsName]
FROM [Person] AS [p]
LEFT JOIN [products] AS [p0] ON [p].[ID] = [p0].[id]
~~~

该语句在数据库中，执行结果如下：

![img](https://img2018.cnblogs.com/common/66059/202002/66059-20200217224749501-1133448722.png)

然后我们可以看到我们的.NET Core程序，输出的结果如下：

![img](https://img2018.cnblogs.com/common/66059/202002/66059-20200217225212006-1923803765.png)

可以看到，由于EF Core中实体类Products的Id属性为**int**类型，不能为**null**，所以EF Core将Products表中为**null**的行输出为了ProductsId=0，而由于实体类Products的Product属性为**string**类型，可以为**null**，所以EF Core将Products表中为**null**的行输出为了ProductsName=Null。

所以可以看到如果要在EF Core中实现**LEFT JOIN**还是有点麻烦的，所以我建议如果在开发过程中我们要写一些很复杂的**LEFT JOIN**、**RIGHT JOIN**、**FULL JOIN**等SQL语句，可以将这些SQL语句写成数据库中的视图或存储过程等数据库对象，然后使用EF Core将数据库中的视图或存储过程等映射为实体类，这样比在EF Core中去构造复杂的SQL语句要方便很多。
